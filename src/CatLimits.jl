module CatLimits
export is_natural_verbose

using StructEquality
using DataStructures: IntDisjointSets, find_root!
using Catlab.Present
using Catlab.Theories
using Catlab.GAT
using Catlab.Syntax
using Catlab.CategoricalAlgebra
import Catlab.CategoricalAlgebra.FinCats: FinCatPresentation
import Catlab.CategoricalAlgebra: ob_map, hom_map, presentation, ob_generators, hom_generators, equations,
  ob_generator, hom_generator, ob_generator_name, hom_generator_name, ob, hom, product, coproduct,
  equalizer, coequalizer, universal
import Catlab.Theories: dom, codom, compose, id

src(C::FinCatGraph, i::Int) = src(graph(C), i)
tgt(C::FinCatGraph, i::Int) = tgt(graph(C), i)

ob_map(F::FinDomFunctor) = Dict([k=>ob_map(F,k) for k in ob_generators(dom(F))])
hom_map(F::FinDomFunctor) = Dict([
  k=>hom_map(F,k) for k in hom_generators(dom(F))])

function is_natural_verbose(α::FinTransformation; check_equations::Bool=true)
  F, G = dom(α), codom(α)
  C, D = dom(F), codom(F) # == dom(G), codom(G)
  all(ob_generators(C)) do c
    α_c = α[c]
    res = dom(D, α_c) == ob_map(F,c) && codom(D, α_c) == ob_map(G,c)
    if !res && verbose
      println("c $c\ndom(D, α_c) $(dom(D, α_c))\nob_map(F,c) $(ob_map(F,c))")
      println("codom(D, α_c) $(codom(D, α_c))\nob_map(G,c) $(ob_map(G,c))")
    end
    res
  end || return false

  if check_equations
    all(hom_generators(C)) do f
      Ff, Gf = hom_map(F,f), hom_map(G,f)
      α_c, α_d = α[dom(C,f)], α[codom(C,f)]
      res = is_hom_equal(D, compose(D, α_c, Gf), compose(D, Ff, α_d))
      if !res && verbose
        println("f $f\nFf $Ff\nGf $Gf\nα_c $α_c\nα_d $α_d")
        println("\tcompose(D, α_c, Gf) $(compose(D, α_c, Gf))")
        println("\tcompose(D, Ff, α_d)) $(compose(D, Ff, α_d)))")
      end
      res
    end || return false
  end
  true
end

# Limits in category of diagrams
#-------------------------------
"""
Decompose a product morphism into a composition of canonical generators, i.e.
morphisms that have exactly one non-ID component
Assumes we have a dictionary that takes us, e.g., from a tuple (f: A->B, idₓ) to
the product morphism (f,idₓ): A×X⟶B×X
"""
function product_decompose(f::Vector, hdict::Dict)
  curr = id.(dom.(f))
  res, n = [], length(f)
  for (i,m) in enumerate(f)
    if (m isa HomExpr{:compose}) margs = m.args
    elseif (m isa HomExpr{:generator}) margs = [m]
    else margs = []
    end
    for marg in margs
      args = tuple([j == i ? marg : curr[j] for j in 1:n]...)
      push!(res, hdict[args])
    end
    curr[i] = id(codom(m))
  end
  return compose(res)
end

"""
Product of finitely-presented categories has the cartesian product of ob
generators as its objects. Its morphisms are generated by, for each morphism in
the underlying categories, taking the product of that morphism with the
identity morphism of all objects of all other categories. For example:
 h                  f   g
X->Y multiplied by A->B<-C is:
                 (f,idY) (g, idY)
                 YA -> YB  <-  YC
         (h,idA) |     |(h,idB) | (h,idC)
                 XA -> XB  <-  XC
                 (f,idX) (g, idX)
For any pair (e.g. f:A->B,h:X->Y), we get a naturality square
                (f,idX)
          A x X  ---->  B x X
            |             |
  (id(A),h) |             | (id(B),h)
          A x Y  --->  B x Y
              (f,id(Y))
For any triple, we get a naturality cube (six naturality squares), and so on.
TODO: figure out whether or not we also require 8 path equations to go from one
corner of the cube to the other, or if that is derivable from the equalities on
the faces of the cube. My intuition is: yes we need these additional equations.
Currently we have no tests that fail due to this.
"""
function product(Xs::AbstractVector{<: FinCatPresentation}; kw...)
  # Get cartesian product of obs and hosm
  obs = collect(Iterators.product([ob_generators(x)  for x in Xs]...))[:]

  homs = vcat(map(enumerate(Xs)) do (i,X)
    vcat(map(hom_generators(X)) do h
      p = Iterators.product([id.(ob_generators(Y)) for (j,Y) in enumerate(Xs) if j!=i]...)
      map(collect.(collect(p)[:])) do hgens
        tuple(insert!(Vector{Any}(hgens), i, h)...)
      end
    end...)
  end...)

  obdict = Dict([v=>k for (k,v) in enumerate(obs)])

  # Create new presentation with tuple-looking names
  p = Presentation(FreeSchema)

  ogens = [Ob(FreeSchema, Symbol(o)) for o in obs]
  map(ogens) do g add_generator!(p, g) end
  hgens = Dict{Any,Any}(map(homs) do hs
    src, tgt = map([dom, codom]) do get
      ogens[obdict[tuple([get(X, h) for (h, X) in zip(hs,Xs)]...)]]
    end
    hs => add_generator!(p, Hom(Symbol(hs), src, tgt))
  end)
  for (k,v) in zip(obs, ogens)
    hgens[tuple(id.(k)...)] = id(v)
  end

  # Add naturality squares
  for i in 1:(length(Xs)-1)
    hgi = hom_generators(Xs[i])
    for j in i+1:length(Xs)
      hgj = hom_generators(Xs[j])
      fun(iarg, jarg, args) = map(1:length(Xs)) do k
        if k==i iarg elseif k==j jarg else args[k] end end
      for hij in Iterators.product(hgi, hgj)
        hi, hj = hij
        args = fun([nothing], [nothing], [id.(ob_generators(x))  for x in Xs])
        for hs in Iterators.product(args...)
          (di, cdi), (dj, cdj) = [id.([dom(x), codom(x)]) for x in hij]
          xs = [hi=>dj, cdi=>hj, di=>hj, hi=>cdj] # naturality square
          a1,a2,b1,b2 = [product_decompose(fun(x1,x2,hs), hgens) for (x1,x2) in xs]
          add_equation!(p, compose(a1,a2), compose(b1,b2))
        end
      end
    end
  end

  # Add equations from base categories
  for (i, X) in enumerate(Xs)
    for lr in equations(X)
      is = [j == i ? [nothing] : id.(ob_generators(x))
            for (j, x) in enumerate(Xs)]
      for bkgrnd in Iterators.product(is...)
        l_, r_ = map(lr) do t
          comps = (t isa HomExpr{:id} || t isa HomExpr{:generator}) ? [t] : t.args
          comps_ = map(comps) do comp
            hgens[tuple([k==i ? comp : c for (k,c) in enumerate(bkgrnd)]...)]
          end
          compose(comps_)
        end
        add_equation!(p, l_, r_)
      end
    end
  end

  # Create projection maps
  apx = FinCat(p)
  ls = map(enumerate(Xs)) do (i, x)
    os, hs = map([obs, homs]) do oldgens
      Dict([Symbol(o) => o[i] for o in oldgens])
    end
    FinDomFunctor(os, hs, apx, x)
  end
  Limit(DiscreteDiagram(Xs), Multispan(ls))
end

"""
TODO: handle equations by filtering those including symbols not in osyms ∪ hsyms
"""
function equalizer(fs::AbstractVector{<:FinDomFunctor{<:FinCatPresentation}})
  # Check fs are parallel finfunctors
  I, _ = only.(Set.([dom.(fs), codom.(fs)]))

  # identify things that maps make equal
  Eo, Eh = map(zip([ob_generators, hom_generators], [ob_map, hom_map])) do (g, m)
     [x for x in g(I) if length(Set([m(f, x) for f in fs])) == 1]
  end
  osyms, hsyms = Set.([Symbol.(Eo), Symbol.(Eh)])

  # Create new sub-presentation of the domain
  p = Presentation(FreeSchema)
  for g in vcat(Eo,Eh) add_generator!(p, g) end

  # Create inclusion morphism
  obs, homs = map([osyms,hsyms]) do syms
    Dict{Symbol,Symbol}(s=>s for s in syms)
  end
  l1 = FinDomFunctor(obs, homs, FinCat(p), I)
  Limit(ParallelMorphisms(fs), Multispan([l1]))
end

"""
Preserves the original name of the inputs if it is unambiguous, otherwise
disambiguates with index in original input. E.g. (A,B)⊔(B,C) → (A,B#1,B#2,C)
"""
function coproduct(Xs::AbstractVector{<: FinCatPresentation}; kw...)
  # Collect all generators and identify conflicting names
  all_ob = vcat(ob_generators.(Xs)...)
  all_hom = vcat(hom_generators.(Xs)...)
  conflict_obs = Set([i for i in all_ob if count(==(i), all_ob) > 1])
  conflict_homs = Set([i for i in all_hom if count(==(i), all_hom) > 1])

  # Create new disjoint union presentation
  p = Presentation(FreeSchema)
  ogens = Dict(vcat(map(enumerate(Xs)) do (i, X)
    map(ob_generators(X)) do o
      (i,o) => Ob(FreeSchema, Symbol("$o" * (o ∈ conflict_obs ? "#$i" : "")))
    end
  end...))
  map(values(ogens)) do g add_generator!(p, g) end

  hgens = Dict(vcat(map(enumerate(Xs)) do (i, X)
    map(hom_generators(X)) do h
      n = Symbol("$h" * (h ∈ conflict_homs ? "#$i" : ""))
      s, t = ogens[(i, dom(X,h))], ogens[(i, codom(X,h))]
      (i,h) => add_generator!(p, Hom(n, s, t))
    end
  end...))

  # Create legs into equationless target to help us project the equations
  for  (i,x) in enumerate(Xs)
    os, hs = map(zip([ob_generators,hom_generators], [ogens,hgens])) do (get, g)
      Dict([Symbol(o) => Symbol(g[(i,o)]) for o in get(x)])
    end
    l = FinDomFunctor(os, hs, x, FinCat(p))
    for (e1,e2) in equations(x)
      add_equation!(p, hom_map(l, e1), hom_map(l, e2))
    end
  end

  # Create legs into equationful target
  ls = map(enumerate(Xs)) do (i,x)
    os, hs = map(zip([ob_generators,hom_generators], [ogens,hgens])) do (get, g)
      Dict([Symbol(o) => Symbol(g[(i,o)]) for o in get(x)])
    end
    FinDomFunctor(os, hs, x, FinCat(p))
  end

  Colimit(DiscreteDiagram(Xs), Multicospan(ls))
end

"""
TODO: handle equations
"""
function coequalizer(fs::AbstractVector{<:FinDomFunctor{<:FinCatPresentation}})
  # Check inputs are parallel finfunctors
  I, J = only.(Set.([dom.(fs), codom.(fs)]))

  # Generate equivalence class reps for the generators of codomain
  f1 = first(fs)
  og, hg = ob_generators, hom_generators
  odict, hdict = map(zip([og, hg], [ob_map, hom_map])) do (gen, map_)
    class = IntDisjointSets(length(gen(J)))
    inds = Dict(v=>k for (k,v) in enumerate(gen(J)))
    map(gen(I)) do o
      map(fs) do f
        union!(class, inds[map_(f1, o)], inds[map_(f, o)])
      end
    end
    Dict(o => gen(J)[find_root!(class, i)] for (i, o) in enumerate(gen(J)))
  end

  # Create presentation from equivalence classes
  p = Presentation(FreeSchema)
  obs, homs = [Dict() for _ in 1:2]
  for i in sort(collect(Set(values(odict))), by=string)
    os = sort([string(k) for (k, v) in collect(odict) if v==i])
    g = add_generator!(p, Ob(FreeSchema, Symbol("[$(join(os,","))]")))
    for o in os
      obs[Symbol(o)] = g
    end
  end
  for i in sort(collect(Set(values(hdict))), by=string)
    hs = sort([k for (k, v) in collect(hdict) if v==i], by=string)
    s, t = map([dom, codom]) do get
      obs[Symbol(get(J, first(hs)))]
    end
    g = add_generator!(p, Hom(Symbol("[$(join(string.(hs),","))]"), s, t))
    for h in hs
      homs[Symbol(h)] = Symbol(g)
    end
  end
  l1 = FinDomFunctor(obs, homs, J, FinCat(p))
  Colimit(ParallelMorphisms(fs), Multicospan([l1]))
end


"""
A generator a that is mapped to generators X,Y,... in the span is matched to the
ob generator (X, Y, ...) in the product.
An edge f:a->b that is mapped to morphisms α,β,γ in the span is matched to a
composite of hom generators that yields the morphism (α,β,γ) in the product.
This composition sequence starts with (α, id(src(β)), id(src(γ))) and ends with
(id(tgt(α)), id(tgt(β)), γ)
"""
function universal(p::Product{<:FinCat}, sp::Multispan)
  a_p, a_sp = apex.([p, sp])
  obs = Dict(map(ob_generators(a_sp)) do o
    p_tgts = [ob_map(l, o) for l in legs(sp)]
    for po in ob_generators(a_p)
      if p_tgts == [ob_map(l, po) for l in legs(p)]
        return o => po
      end
    end
    error("o $o (w/ tgts $p_tgts) not found")
  end)
  homs = Dict(map(hom_generators(a_sp)) do h
    doms, codoms = map([dom, codom]) do get
      id.([get(codom(l), hom_map(l, h)) for l in legs(sp)])
    end
    # Find the morphism generators we want to map to
    h_comps = map(enumerate(legs(sp))) do (i, l)
      # Identify morphism by what the product maps it to
      h_tgt = map(1:length(legs(sp))) do j
        if j < i      codoms[j]
        elseif j == i hom_map(l, h)
        else          doms[j]
        end
      end
      """
      WARNING: if the hom map component is composite, it won't be found below.
      Need to break up compose into components with `product_decompose`
      """
      # Locate this morphism based on what it maps to
      for ph in vcat(hom_generators(a_p), id.(ob_generators(a_p)))
        if h_tgt == [hom_map(l, ph) for l in legs(p)]
          return ph
        end
      end
      error("h $h -> htgt $h_tgt not found")
    end
    h => compose(h_comps)
  end)
  FinFunctor(obs, homs, a_sp, a_p)
end


function universal(cp::Coproduct{<:FinCat}, csp::Multicospan)
  a_cp, a_csp = apex.([cp, csp])
  obs, homs = Dict(), Dict()
  for (cpl, cspl) in zip(legs(cp),legs(csp))
    for o in ob_generators(dom(cpl))
      obs[ob_map(cpl, o)] = ob_map(cspl, o)
    end
    for h in hom_generators(dom(cpl))
      homs[hom_map(cpl, h)] = hom_map(cspl, h)
    end
  end
  FinFunctor(obs, homs, a_cp, a_csp)
end

function universal(eq::Equalizer{<:FinCat}, f::FinDomFunctor)
  FinFunctor(ob_map(f), hom_map(f), dom(f), apex(eq))
end

function universal(ceq::Coequalizer{<:FinCat}, f::FinDomFunctor)
  obs = Dict([ob_map(proj(ceq), k) => v for (k,v) in ob_map(f)])
  homs = Dict([hom_map(proj(ceq), k) => v for (k,v) in hom_map(f)])
  FinFunctor(obs, homs, apex(ceq), codom(f))
end

end